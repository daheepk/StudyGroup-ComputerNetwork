# 전송계층 2~4

# tcp flow control

![Untitled 1](https://github.com/user-attachments/assets/69377748-04f1-426b-b1ca-ec005f2fe7f5)

TCP 흐름 제어는 네트워크 통신에서 송신자가 수신자의 처리 능력을 초과하는 속도로 데이터를 전송하는 것을 방지하는 메커니즘입니다. 이는 네트워크의 효율성을 높이고 데이터 손실을 방지하는 데 중요한 역할을 합니다.

<aside>
💡 **receiver의 buffer 눈치를 보고 sender의 window size를 조절하는 것**

</aside>

### 동작 과정

![Untitled 2](https://github.com/user-attachments/assets/3567d9a1-b1a1-41a0-9d0d-0d2767b09bb5)

1. 연결 설정:
    - TCP 3-way 핸드쉐이크를 통해 연결이 설정됩니다.
    - 이 과정에서 초기 윈도우 크기가 교환됩니다.
2. 데이터 전송 시작:
    - 송신자는 수신자의 윈도우 크기 내에서 데이터를 전송합니다.
    - 각 세그먼트에는 순서 번호가 부여됩니다.
3. 수신자 처리:
    - 수신자는 도착한 데이터를 버퍼에 저장합니다.
    - 데이터를 처리하고 애플리케이션에 전달합니다.
4. 확인 응답(ACK) 전송:
    - 수신자는 성공적으로 받은 데이터에 대해 ACK를 송신자에게 보냅니다.
    - ACK에는 다음에 기대하는 순서 번호와 현재 윈도우 크기가 포함됩니다.
5. 윈도우 크기 조정:
    - 수신자는 자신의 처리 능력과 버퍼 상태에 따라 윈도우 크기를 조정합니다.
    - 이 정보는 ACK 패킷의 윈도우 필드를 통해 송신자에게 전달됩니다.
6. 송신자의 전송 속도 조절:
    - 송신자는 수신자가 알린 윈도우 크기에 맞춰 전송 속도를 조절합니다.
    - 윈도우가 작아지면 전송 속도를 줄이고, 커지면 속도를 높입니다.
7. 제로 윈도우 상황 처리:
    - 수신자의 버퍼가 가득 차면 윈도우 크기를 0으로 설정할 수 있습니다.
    - 송신자는 전송을 중단하고 주기적으로 윈도우 프로브를 보내 상태를 확인합니다.
8. 윈도우 갱신:
    - 수신자의 버퍼 공간이 확보되면 윈도우 업데이트를 송신자에게 보냅니다.
    - 송신자는 이를 받아 데이터 전송을 재개합니다.
9. 슬라이딩 윈도우 이동:
    - ACK를 받을 때마다 송신자의 윈도우가 오른쪽으로 이동합니다.
    - 이를 통해 새로운 데이터를 전송할 수 있게 됩니다.
10. 타임아웃 및 재전송:
    - ACK가 일정 시간 내에 오지 않으면 송신자는 해당 세그먼트를 재전송합니다.
    - 이는 흐름 제어와 함께 신뢰성 있는 전송을 보장합니다.
11. 지속적인 모니터링 및 조정:
    - 전체 과정에서 네트워크 상황과 수신자의 처리 능력을 지속적으로 모니터링합니다.
    - 필요에 따라 윈도우 크기와 전송 속도를 동적으로 조정합니다.

이러한 과정을 통해 TCP는 효율적이고 안정적인 데이터 전송을 보장하며, 네트워크의 다양한 상황에 적응할 수 있습니다. 송신자와 수신자 간의 지속적인 피드백과 조정이 TCP 흐름 제어의 핵심입니다.

### 주요 특징

1. 슬라이딩 윈도우: 수신자가 처리할 수 있는 데이터의 양을 동적으로 조절합니다.
2. 윈도우 크기 조정: 네트워크 상황과 수신자의 처리 능력에 따라 조절됩니다.
3. 흐름 제어 필드: TCP 헤더의 윈도우 크기 필드를 통해 수신 가능한 데이터 양을 알립니다.
4. 확인 응답(ACK): 수신된 데이터에 대한 확인을 송신자에게 전송합니다.
5. 버퍼 관리: 수신자는 수신 버퍼를 사용하여 데이터를 임시 저장합니다.

### 관련 기술 질문

- **TCP의 슬라이딩 윈도우 메커니즘**:
슬라이딩 윈도우는 송신자가 ACK를 기다리지 않고 연속적으로 전송할 수 있는 데이터의 범위를 나타냅니다. ACK를 받으면 윈도우가 오른쪽으로 이동하여 새로운 데이터를 전송할 수 있게 됩니다. 이는 네트워크 효율성을 높이고 지연 시간을 줄입니다.
- **TCP 흐름 제어와 혼잡 제어의 차이점**:
흐름 제어는 송신자와 수신자 간의 데이터 처리 속도 차이를 관리합니다. 반면 혼잡 제어는 네트워크의 전반적인 부하를 관리하여 패킷 손실과 지연을 방지합니다. 흐름 제어는 엔드포인트 간의 문제를, 혼잡 제어는 네트워크 전체의 문제를 다룹니다.
- **TCP 윈도우 스케일링 옵션**:
윈도우 스케일링은 기본 16비트 윈도우 크기 필드의 한계를 극복하기 위한 옵션입니다. 이는 윈도우 크기에 2의 거듭제곱을 곱하여 최대 1GB까지 확장할 수 있게 합니다. 고속 네트워크에서 더 큰 윈도우를 사용할 수 있게 하여 성능을 향상시킵니다.
- **제로 윈도우 상황**:
수신자의 버퍼가 가득 차서 더 이상 데이터를 받을 수 없을 때 발생합니다. 이를 해결하기 위해 송신자는 전송을 중단하고 주기적으로 윈도우 프로브를 보내 수신자의 상태를 확인합니다. 수신자는 버퍼 공간이 확보되면 윈도우 업데이트를 보내 전송 재개를 알립니다.
- **Nagle 알고리즘의 영향**:
Nagle 알고리즘은 작은 패킷들을 모아 큰 패킷으로 전송함으로써 네트워크 효율성을 높입니다. 이는 흐름 제어와 상호작용하여 작은 데이터의 즉시 전송을 지연시킬 수 있습니다. 때문에 실시간성이 중요한 애플리케이션에서는 비활성화하기도 합니다.
- **TCP keep-alive와 흐름 제어의 관계**:
Keep-alive 메커니즘은 연결의 지속성을 확인하는 데 사용되며, 직접적인 흐름 제어 기능은 아닙니다. 하지만 장기간 유휴 상태의 연결에서 네트워크 상태 변화를 감지하는 데 도움을 줄 수 있어, 간접적으로 흐름 제어에 영향을 미칠 수 있습니다.
- **SACK 옵션의 흐름 제어 효율성 영향**:
SACK은 선택적 확인 응답을 가능하게 하여, 손실된 세그먼트만을 재전송할 수 있게 합니다. 이는 불필요한 재전송을 줄이고 네트워크 효율성을 높여 흐름 제어의 효율성을 개선합니다. 특히 높은 대역폭과 긴 지연 시간을 가진 네트워크에서 성능 향상에 크게 기여합니다.

# congestion control

![Untitled 3](https://github.com/user-attachments/assets/f4149e5b-4490-4bad-9542-eaef65d35845)

**congestion control**은 송신 서버의 데이터 전송과 네트워크의 처리 속도 차이로 인한 네트워크 혼잡을 해결하기 위한 기법이며, 이를 위해 송신측에 혼잡 윈도우(cwnd)를 설정한다.

**주요 특징:**

- 혼잡 윈도우(cwnd): 네트워크 상태에 따라 조절되는 송신자의 전송 가능 데이터 양
- 슬로우 스타트(Slow Start): 연결 초기에 네트워크 용량을 탐색하는 단계
- 혼잡 회피(Congestion Avoidance): 네트워크 용량에 근접했을 때의 완만한 증가 단계
- 빠른 재전송(Fast Retransmit): 패킷 손실을 빠르게 감지하고 대응하는 메커니즘
- 빠른 회복(Fast Recovery): 패킷 손실 후 전송률을 신속하게 복구하는 방법

**동작 과정:**

1. 슬로우 스타트:
    - 초기 cwnd를 1 MSS(Maximum Segment Size)로 설정
    - 매 RTT(Round Trip Time)마다 cwnd를 2배로 증가
    - ssthresh(slow start threshold)에 도달할 때까지 계속
2. 혼잡 회피:
    - ssthresh 이후 cwnd를 선형적으로 증가 (매 RTT마다 1 MSS씩)
    - 네트워크 용량에 근접했다고 판단될 때 사용
3. 혼잡 감지:
    - 타임아웃 발생 또는 중복 ACK 수신으로 패킷 손실 감지
    - 혼잡으로 간주하고 cwnd 감소
4. 빠른 재전송 및 빠른 회복:
    - 3개의 중복 ACK 수신 시 즉시 해당 세그먼트 재전송
    - cwnd를 절반으로 줄이고 선형 증가 단계로 전환
5. 타임아웃 발생 시:
    - cwnd를 1 MSS로 줄이고 슬로우 스타트 단계로 돌아감
    - ssthresh를 현재 cwnd의 절반으로 설정
6. 지속적인 모니터링 및 조정:
    - RTT, 패킷 손실률 등을 지속적으로 모니터링
    - 네트워크 상황에 따라 cwnd와 ssthresh 동적 조정

**기술 질문 및 답변:**
**Q1: TCP 혼잡 제어의 슬로우 스타트와 혼잡 회피 단계의 차이점은 무엇인가요?**
A1: 슬로우 스타트는 cwnd를 지수적으로 증가시켜 빠르게 네트워크 용량을 탐색하는 단계입니다. 반면 혼잡 회피는 cwnd를 선형적으로 증가시켜 네트워크 용량에 서서히 접근합니다. 슬로우 스타트는 연결 초기나 심각한 혼잡 후에 사용되고, 혼잡 회피는 네트워크 용량에 근접했다고 판단될 때 사용됩니다.
**Q2: TCP Reno와 TCP Cubic의 주요 차이점은 무엇인가요?**
A2: TCP Reno는 선형적인 혼잡 회피를 사용하는 반면, TCP Cubic은 3차 함수를 사용하여 cwnd를 조절합니다. Cubic은 높은 대역폭과 긴 지연 시간을 가진 네트워크에서 더 효율적이며, 패킷 손실 후 더 빠르게 이전 전송률로 복귀할 수 있습니다.
**Q3: ECN(Explicit Congestion Notification)이 TCP 혼잡 제어에 어떤 영향을 미치나요?**
A3: ECN은 패킷 손실 없이 네트워크 혼잡을 명시적으로 알리는 메커니즘입니다. 이를 통해 TCP는 실제 패킷 손실이 발생하기 전에 선제적으로 전송률을 조절할 수 있어, 더 효율적인 혼잡 제어가 가능해집니다. ECN을 사용하면 불필요한 재전송을 줄이고 전체적인 네트워크 성능을 향상시킬 수 있습니다.
**Q4: BBR(Bottleneck Bandwidth and Round-trip propagation time) 혼잡 제어 알고리즘의 주요 특징은 무엇인가요?**
A4: BBR은 패킷 손실이 아닌 네트워크의 실제 대역폭과 RTT를 기반으로 혼잡 제어를 수행합니다. 이는 네트워크 경로의 병목 대역폭과 왕복 전파 시간을 모델링하여 최적의 전송률을 찾습니다. BBR은 특히 높은 대역폭-지연 곱(BDP) 네트워크에서 기존 알고리즘보다 더 나은 성능을 보입니다.
**Q5: TCP 혼잡 제어에서 AIMD(Additive Increase Multiplicative Decrease) 원칙이 왜 중요한가요?**
A5: AIMD는 네트워크 리소스의 공정한 분배와 안정성을 보장하는 중요한 원칙입니다. 선형적 증가(Additive Increase)는 네트워크 용량에 천천히 접근하여 과도한 혼잡을 방지하고, 곱셈적 감소(Multiplicative Decrease)는 혼잡 발생 시 빠르게 전송률을 줄여 네트워크 안정성을 확보합니다. 이 방식은 여러 TCP 연결 간의 공정성을 유지하는 데도 도움이 됩니다.

# syn bit

![Untitled 4](https://github.com/user-attachments/assets/56f4df35-d9e9-4d9c-ab2f-ddec3946a5d6)

## SYN 비트란:

SYN(Synchronize) 비트는 TCP 헤더의 컨트롤 비트 중 하나로, TCP 연결 설정 과정에서 중요한 역할을 합니다. 이 비트는 새로운 연결을 시작하고자 할 때 사용되며, 두 호스트 간의 초기 순서 번호를 동기화하는 데 핵심적인 역할을 합니다.

**주요 특징:**

1. 연결 초기화: 새로운 TCP 연결을 시작할 때 사용됩니다.
2. 순서 번호 동기화: 초기 순서 번호(ISN)를 설정하는 데 사용됩니다.
3. 3-way 핸드쉐이크: TCP 연결 설정 과정의 첫 번째 단계에서 사용됩니다.
4. 1비트 크기: TCP 헤더의 컨트롤 비트 필드에 위치합니다.
5. 보안 고려사항: SYN 플러딩 공격과 같은 보안 위협의 대상이 될 수 있습니다.

## **동작 과정:**

1. **연결 시작:**
    - 클라이언트가 서버에 연결을 요청할 때 SYN 비트를 1로 설정한 세그먼트를 전송합니다.
    - 이 세그먼트에는 클라이언트의 초기 순서 번호(ISN)가 포함됩니다.
2. **서버 응답:**
    - 서버는 SYN 비트가 설정된 세그먼트를 받으면, SYN과 ACK 비트를 모두 1로 설정한 세그먼트로 응답합니다.
    - 이 응답에는 서버의 ISN과 클라이언트의 ISN에 1을 더한 값(ACK 번호)이 포함됩니다.
3. **연결 완료:**
    - 클라이언트는 서버의 SYN-ACK에 대해 ACK로 응답하며, 이로써 3-way 핸드쉐이크가 완료됩니다.
    - 이후의 데이터 전송 세그먼트에서는 SYN 비트가 0으로 설정됩니다.
4. **연결 종료:**
    - 연결 종료 시에는 SYN 비트 대신 FIN 비트가 사용됩니다.
5. **재전송 메커니즘:**
    - SYN 세그먼트가 손실될 경우, 타임아웃 후 재전송됩니다.
    - 재전송 간격은 일반적으로 지수적으로 증가합니다.
6. **보안 고려사항:**
    - SYN 쿠키나 SYN 캐시와 같은 기술을 사용하여 SYN 플러딩 공격에 대비합니다.

## 기술 질문 및 답변:

**Q1: TCP의 3-way 핸드쉐이크 과정에서 SYN 비트의 역할을 설명해주세요.**
A1: SYN 비트는 3-way 핸드쉐이크의 첫 두 단계에서 중요한 역할을 합니다. 첫 번째 단계에서 클라이언트는 SYN 비트를 1로 설정하여 연결 요청을 보냅니다. 두 번째 단계에서 서버는 SYN과 ACK 비트를 모두 1로 설정하여 응답합니다. 이를 통해 양쪽의 초기 순서 번호가 동기화되고, 연결 설정을 위한 기반이 마련됩니다.

**Q2: SYN 플러딩 공격이란 무엇이며, 이를 방지하기 위한 방법은 무엇인가요?**
A2: SYN 플러딩은 공격자가 대량의 SYN 패킷을 서버에 보내 서버의 리소스를 고갈시키는 DoS 공격 유형입니다. 이를 방지하기 위해 다음과 같은 방법들이 사용됩니다:

1. SYN 쿠키: 서버가 SYN-ACK를 보낼 때 연결 정보를 저장하지 않고, 클라이언트의 ACK에서 이를 검증합니다.
2. 연결 대기열 관리: SYN 받은 연결의 대기열 크기를 제한합니다.
3. 패킷 필터링: 비정상적인 SYN 패킷을 탐지하고 차단합니다.
4. TCP 인터셉트: 방화벽이 클라이언트와의 연결을 대신 완료한 후 서버에 연결합니다.

**Q3: TCP Fast Open에서 SYN 비트는 어떻게 활용되나요?**
A3: TCP Fast Open은 연결 설정과 데이터 전송을 동시에 수행하여 지연시간을 줄이는 기술입니다. 이 과정에서 SYN 비트가 설정된 세그먼트에 TFO(TCP Fast Open) 쿠키와 초기 데이터가 함께 포함됩니다. 서버는 이 쿠키를 검증하고, 유효할 경우 SYN-ACK와 함께 데이터에 대한 응답을 즉시 보낼 수 있습니다. 이를 통해 하나의 RTT를 절약할 수 있습니다.

**Q4: SYN 비트와 관련된 TCP 상태 변화를 설명해주세요.**
A4: SYN 비트는 TCP 연결 상태 변화에 중요한 역할을 합니다:

1. CLOSED → SYN-SENT: 클라이언트가 SYN을 보내면서 변경
2. LISTEN → SYN-RECEIVED: 서버가 SYN을 받고 SYN-ACK를 보내면서 변경
3. SYN-SENT → ESTABLISHED: 클라이언트가 SYN-ACK를 받고 ACK를 보내면서 변경
4. SYN-RECEIVED → ESTABLISHED: 서버가 ACK를 받으면서 변경
이러한 상태 변화는 SYN 비트의 사용과 직접적으로 연관되어 있습니다.

**Q5: SYN 비트가 설정된 세그먼트의 재전송 메커니즘은 일반 데이터 세그먼트와 어떻게 다른가요?**
A5: SYN 세그먼트의 재전송 메커니즘은 일반 데이터 세그먼트와 몇 가지 차이점이 있습니다:

1. 재전송 간격: SYN 세그먼트는 일반적으로 지수적 백오프를 사용하여 재전송 간격을 증가시킵니다.
2. 재전송 횟수: 대부분의 시스템에서 SYN 재전송 횟수는 일반 세그먼트보다 적습니다(보통 3-5회).
3. 초기 타임아웃: SYN 세그먼트의 초기 타임아웃은 일반적으로 더 길게 설정됩니다.
4. 혼잡 제어: SYN 재전송은 일반적인 혼잡 제어 메커니즘을 따르지 않습니다.

이러한 차이는 연결 설정 과정의 특수성과 SYN 플러딩과 같은 공격에 대한 방어를 고려한 것입니다.

# 3way hand shake

![Untitled 5](https://github.com/user-attachments/assets/0c37a091-b4e7-4d8b-bf39-7a8b733d32de)

## 3-way handshake란:

3-way handshake는 TCP 연결을 설정하는 과정으로, 클라이언트와 서버 간에 신뢰성 있는 연결을 수립하기 위해 사용되는 방법입니다. 이 과정을 통해 양쪽 호스트는 서로의 존재를 확인하고, 초기 순서 번호를 동기화하며, 연결 매개변수를 협상합니다.

## 주요 특징:

1. 연결 초기화: 데이터 전송 전 안정적인 연결을 보장합니다.
2. 순서 번호 동기화: 양쪽의 초기 순서 번호(ISN)를 설정합니다.
3. 양방향 통신 확인: 클라이언트와 서버 모두 송수신 능력을 확인합니다.
4. 상태 변화: CLOSED, LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED 상태를 거칩니다.
5. 플래그 사용: 주로 SYN과 ACK 플래그를 사용합니다.

## 상세 동작 과정:

1. 1단계: SYN (클라이언트 → 서버)
    - 클라이언트는 연결을 시작하기 위해 SYN 패킷을 서버로 전송합니다.
    - SYN 플래그가 1로 설정됩니다.
    - 클라이언트의 초기 순서 번호(ISN)가 포함됩니다.
    - 클라이언트 상태: CLOSED → SYN-SENT
2. 2단계: SYN-ACK (서버 → 클라이언트)
    - 서버는 클라이언트의 SYN을 수신하고 SYN-ACK 패킷으로 응답합니다.
    - SYN과 ACK 플래그가 모두 1로 설정됩니다.
    - 서버의 ISN이 포함됩니다.
    - 확인 응답 번호는 클라이언트의 ISN + 1입니다.
    - 서버 상태: LISTEN → SYN-RECEIVED
3. 3단계: ACK (클라이언트 → 서버)
    - 클라이언트는 서버의 SYN-ACK를 수신하고 ACK로 응답합니다.
    - ACK 플래그가 1로 설정됩니다.
    - 확인 응답 번호는 서버의 ISN + 1입니다.
    - 클라이언트 상태: SYN-SENT → ESTABLISHED
    - 서버 상태: SYN-RECEIVED → ESTABLISHED
4. 연결 설정 완료
    - 이 시점에서 양방향 통신이 가능한 전이중(full-duplex) 연결이 설정됩니다.

## 추가 고려사항:

1. 타임아웃 처리:
    - 각 단계에서 응답이 없을 경우 타임아웃 후 재시도합니다.
    - 일정 횟수 이상 실패하면 연결 시도를 포기합니다.
2. 동시 개방(Simultaneous Open):
    - 양쪽에서 동시에 SYN을 보내는 경우, 특별한 처리가 필요합니다.
3. 보안 고려사항:
    - SYN 플러딩 공격 방지를 위한 SYN 쿠키 등의 기술이 적용될 수 있습니다.
4. 옵션 협상:
    - MSS(Maximum Segment Size), 윈도우 스케일링, SACK 허용 등의 TCP 옵션이 이 과정에서 협상됩니다.

## 기술 질문 및 답변:

**Q1: 3-way handshake 과정에서 사용되는 TCP 헤더 필드들을 설명해주세요.**
A1: 3-way handshake에서 주요하게 사용되는 TCP 헤더 필드들은 다음과 같습니다:

1. 순서 번호(Sequence Number): 각 호스트의 ISN을 전달합니다.
2. 확인 응답 번호(Acknowledgment Number): 상대방의 순서 번호를 확인합니다.
3. 컨트롤 비트(Control Bits): SYN, ACK 플래그를 사용합니다.
4. 윈도우 크기(Window Size): 수신 윈도우 크기를 알립니다.
5. 옵션(Options): MSS, 윈도우 스케일링 등을 협상합니다.

**Q2: 3-way handshake 과정에서 발생할 수 있는 문제 상황과 그 해결 방법에 대해 설명해주세요.**
A2: 주요 문제 상황과 해결 방법은 다음과 같습니다:

1. SYN 플러딩: SYN 쿠키, SYN 캐시, 연결 대기열 관리 등으로 대응합니다.
2. 패킷 손실: 타임아웃과 재전송 메커니즘을 사용합니다.
3. 동시 개방: 특별한 상태 전이 규칙을 적용하여 처리합니다.
4. 재사용된 포트로 인한 혼란: TIME_WAIT 상태와 타임스탬프 옵션으로 관리합니다.

**Q3: 3-way handshake와 4-way handshake의 차이점은 무엇인가요?**
A3: 3-way handshake는 TCP 연결 설정에 사용되고, 4-way handshake는 연결 종료에 사용됩니다. 주요 차이점은:

1. 사용 목적: 3-way는 연결 수립, 4-way는 연결 종료
2. 사용 플래그: 3-way는 주로 SYN과 ACK, 4-way는 FIN과 ACK
3. 단계 수: 3-way는 3단계, 4-way는 4단계 (각 방향의 연결을 개별적으로 종료)
4. 상태 변화: 4-way에서는 TIME_WAIT 상태가 추가로 발생

**Q4: TCP Fast Open이 3-way handshake에 미치는 영향에 대해 설명해주세요.**
A4: TCP Fast Open(TFO)은 3-way handshake 과정을 최적화합니다:

1. 첫 연결: 일반적인 3-way handshake를 수행하며, 서버가 TFO 쿠키를 클라이언트에게 제공합니다.
2. 후속 연결: 클라이언트는 SYN 패킷에 TFO 쿠키와 초기 데이터를 함께 전송합니다.
3. 성능 향상: 연결 설정 시 1 RTT를 절약할 수 있어, 짧은 연결에서 특히 유용합니다.
4. 보안 고려: TFO 쿠키를 사용하여 replay 공격을 방지합니다.

**Q5: 3-way handshake 과정에서 초기 순서 번호(ISN)를 무작위로 선택하는 이유는 무엇인가요?**
A5: ISN을 무작위로 선택하는 주요 이유는 다음과 같습니다:

1. 보안 강화: 예측 가능한 ISN은 TCP 시퀀스 번호 예측 공격에 취약합니다.
2. 이전 연결과의 구분: 같은 4-튜플(소스 IP, 목적지 IP, 소스 포트, 목적지 포트)을 사용하는 이전 연결의 패킷과 새 연결의 패킷을 명확히 구분할 수 있습니다.
3. 타임스탬프 기능 지원: 무작위 ISN은 TCP 타임스탬프 옵션과 함께 사용되어 패킷의 나이를 정확히 측정하는 데 도움을 줍니다.
4. 연결의 고유성 보장: 각 연결에 대해 고유한 식별자 역할을 합니다.

이러한 개념들은 TCP 프로토콜의 신뢰성과 보안성을 높이는 데 중요한 역할을 합니다. 3-way handshake는 TCP의 기본적인 동작 원리를 이해하는 데 핵심적인 개념이며, 네트워크 프로그래밍과 트러블슈팅에 필수적인 지식입니다.

# rdtp

![Untitled 7](https://github.com/user-attachments/assets/df1d02a9-bb99-46e6-a39f-d8bc0361026f)

## RDTP란:

RDTP는 신뢰성 있는 데이터 전송을 위한 프로토콜의 개념적 모델입니다. 실제 구현된 프로토콜이 아니라 네트워크 계층 위에서 동작하는 신뢰성 있는 데이터 전송 메커니즘을 설명하기 위한 이론적 모델입니다.

## 주요 특징:

1. 신뢰성: 데이터의 손실, 손상, 중복, 순서 뒤바뀜 없이 전송을 보장합니다.
2. 단순성: 기본적인 개념을 설명하기 위한 단순화된 모델입니다.
3. 점진적 개선: 기본 모델에서 시작하여 다양한 문제를 해결하며 발전합니다.
4. 양방향 통신: 데이터와 확인 응답(ACK)의 양방향 흐름을 다룹니다.
5. 오류 제어: 체크섬, 타임아웃, 재전송 등의 메커니즘을 포함합니다.

## RDTP의 발전 단계:

1. rdt1.0: 완벽한 채널 가정
    - 오류나 손실이 없는 이상적인 채널을 가정합니다.
    - 단순히 데이터를 보내고 받는 것만으로 충분합니다.
2. rdt2.0: 비트 오류 대응
    - 체크섬을 도입하여 비트 오류를 감지합니다.
    - ACK(긍정 확인)와 NAK(부정 확인)를 사용합니다.
    - 오류 발생 시 재전송합니다.
3. rdt2.1: ACK/NAK 손상 대응
    - ACK/NAK에도 오류가 발생할 수 있음을 고려합니다.
    - 순서 번호를 도입하여 중복 전송을 방지합니다.
4. rdt2.2: NAK 없이 구현
    - NAK 대신 마지막으로 성공적으로 수신한 패킷의 ACK를 사용합니다.
    - 중복 ACK를 재전송의 트리거로 사용합니다.
5. rdt3.0: 채널 손실 대응
    - 타임아웃 메커니즘을 도입합니다.
    - 일정 시간 동안 ACK가 오지 않으면 재전송합니다.
    - Stop-and-Wait 프로토콜의 형태를 가집니다.
6. 파이프라이닝 도입
    - 여러 패킷을 연속으로 전송하여 효율성을 높입니다.
    - Go-Back-N 또는 Selective Repeat 방식을 사용합니다.

## 동작 과정 (rdt3.0 기준):

1. 송신자:
    - 데이터에 순서 번호와 체크섬을 추가하여 패킷을 생성합니다.
    - 패킷을 전송하고 타이머를 시작합니다.
    - ACK를 기다립니다.
    - 타임아웃 발생 시 재전송합니다.
2. 수신자:
    - 패킷을 수신하고 체크섬을 확인합니다.
    - 오류가 없으면 데이터를 상위 계층에 전달하고 ACK를 송신합니다.
    - 오류가 있으면 패킷을 폐기하고 이전 패킷의 ACK를 재전송합니다.
3. 흐름 제어:
    - Stop-and-Wait 방식으로 한 번에 하나의 패킷만 전송합니다.

## 기술 질문 및 답변:

**Q1: RDTP의 각 버전별 주요 개선 사항을 설명해주세요.**
A1: RDTP의 주요 버전별 개선 사항은 다음과 같습니다:

- rdt1.0 → rdt2.0: 체크섬과 ACK/NAK 도입으로 비트 오류 대응
- rdt2.0 → rdt2.1: 순서 번호 도입으로 ACK/NAK 손상 대응
- rdt2.1 → rdt2.2: NAK 제거, 중복 ACK 사용으로 프로토콜 단순화
- rdt2.2 → rdt3.0: 타임아웃 메커니즘 도입으로 패킷 손실 대응
- rdt3.0 → 파이프라이닝: 연속 전송으로 효율성 향상

**Q2: RDTP의 Stop-and-Wait 방식과 파이프라이닝 방식의 차이점과 각각의 장단점을 설명해주세요.**
A2:
Stop-and-Wait:

- 특징: 한 번에 하나의 패킷만 전송
- 장점: 구현이 단순, 버퍼 요구사항 최소화
- 단점: 채널 사용 효율성 낮음, 높은 지연 시간

파이프라이닝:

- 특징: 여러 패킷을 연속으로 전송
- 장점: 채널 사용 효율성 높음, 낮은 지연 시간
- 단점: 복잡한 구현, 더 큰 버퍼 필요, 순서 관리 필요

**Q3: RDTP에서 사용되는 오류 제어 메커니즘들을 설명해주세요.**
A3: RDTP의 주요 오류 제어 메커니즘은 다음과 같습니다:

1. 체크섬: 데이터 무결성 검사
2. 확인 응답(ACK/NAK): 성공적인 수신 또는 오류 발생 알림
3. 순서 번호: 중복 패킷 감지 및 순서 보장
4. 타임아웃 및 재전송: 패킷 손실 대응
5. 중복 ACK: 패킷 손실 빠른 감지
6. 선택적 재전송(Selective Repeat): 손실된 패킷만 재전송

**Q4: RDTP의 흐름 제어와 TCP의 흐름 제어의 차이점은 무엇인가요?**
A4:
RDTP (기본 모델):

- Stop-and-Wait 방식 사용
- 수신자의 처리 능력을 고려하지 않음
- 단순한 구현, 제한된 효율성

TCP:

- 슬라이딩 윈도우 기법 사용
- 수신자의 버퍼 상태를 고려한 동적 윈도우 크기 조절
- 복잡한 구현, 높은 효율성
- 혼잡 제어와 결합된 흐름 제어

**Q5: RDTP의 개념이 실제 네트워크 프로토콜 설계에 어떻게 적용되었나요?**
A5: RDTP의 개념은 다음과 같이 실제 프로토콜에 적용되었습니다:

1. TCP: 순서 번호, 확인 응답, 체크섬, 타임아웃 및 재전송 메커니즘 적용
2. UDP 기반 신뢰성 프로토콜: RUDP, UDT 등에서 RDTP 개념 응용
3. ARQ(Automatic Repeat reQuest) 기법: 다양한 데이터 링크 계층 프로토콜에 적용
4. 실시간 통신 프로토콜: RTP/RTCP에서 순서 번호와 타임스탬프 개념 사용
5. 우주 통신: 딥 스페이스 네트워크에서 사용되는 프로토콜에 RDTP 개념 적용

RDTP는 실제 구현된 프로토콜이 아니라 개념적 모델이지만, 그 기본 원리들은 현대의 많은 통신 프로토콜에 핵심적으로 적용되고 있습니다. 이 모델을 이해하는 것은 네트워크 프로토콜의 기본 원리를 파악하는 데 매우 중요합니다.

# pipelined protocols

## Pipelined Protocols란:

Pipelined Protocols는 네트워크 통신에서 여러 패킷을 연속적으로 전송하는 기법을 말합니다. 이는 Stop-and-Wait 프로토콜의 한계를 극복하고 네트워크 리소스 활용도를 높이기 위해 고안되었습니다.

## 주요 특징:

1. 연속 전송: 확인 응답(ACK)을 기다리지 않고 여러 패킷을 연속해서 전송합니다.
2. 높은 효율성: 네트워크 대역폭을 더 효율적으로 사용합니다.
3. 복잡한 관리: 순서 번호, 버퍼 관리 등 복잡한 메커니즘이 필요합니다.
4. 윈도우 기반: 송신 윈도우와 수신 윈도우 개념을 사용합니다.
5. 오류 제어: 패킷 손실, 순서 뒤바뀜 등에 대한 처리 메커니즘이 필요합니다.

## 주요 Pipelined Protocols:

1. **Go-Back-N (GBN)**
    - 특징: 오류 발생 시 윈도우 내의 모든 패킷을 재전송
    - 송신 윈도우: N개의 패킷 포함
    - 수신 윈도우: 1개의 패킷만 포함 (순서대로 수신)
2. **Selective Repeat (SR)**
    - 특징: 오류가 발생한 패킷만 선택적으로 재전송
    - 송신 윈도우: N개의 패킷 포함
    - 수신 윈도우: N개의 패킷 포함 (순서 없이 수신 가능)

## 동작 과정:

1. **송신자:**
    - 윈도우 크기만큼의 패킷을 연속해서 전송합니다.
    - 각 패킷에 순서 번호를 부여합니다.
    - ACK를 받으면 윈도우를 이동시킵니다.
    - 타임아웃 발생 시 재전송을 수행합니다 (GBN: 윈도우 전체, SR: 해당 패킷만).
2. **수신자:**
    - 수신한 패킷의 순서 번호를 확인합니다.
    - 정상 수신 시 ACK를 전송합니다.
    - GBN: 순서가 맞지 않는 패킷은 폐기합니다.
    - SR: 순서가 맞지 않는 패킷도 버퍼에 저장하고 ACK를 보냅니다.
3. **윈도우 관리:**
    - 송신 윈도우: ACK를 받으면 윈도우를 앞으로 이동시킵니다.
    - 수신 윈도우: 순서대로 패킷을 처리하면서 윈도우를 이동시킵니다.

## 기술 질문 및 답변:

**Q1: Go-Back-N과 Selective Repeat의 주요 차이점과 각각의 장단점을 설명해주세요.**
A1:
**Go-Back-N (GBN):**

- 특징: 오류 발생 시 윈도우 내 모든 패킷 재전송
- 장점: 수신자 구현이 간단, 순서 관리가 쉬움
- 단점: 불필요한 재전송으로 인한 대역폭 낭비

**Selective Repeat (SR):**

- 특징: 오류 발생 패킷만 선택적 재전송
- 장점: 효율적인 대역폭 사용, 재전송 최소화
- 단점: 복잡한 구현, 수신자의 버퍼 관리 필요

**Q2: Pipelined Protocols에서 윈도우 크기가 성능에 미치는 영향을 설명해주세요.**
A2: 윈도우 크기는 성능에 다음과 같은 영향을 미칩니다:

1. 큰 윈도우 크기:
    - 장점: 높은 처리량, 효율적인 대역폭 사용
    - 단점: 더 많은 버퍼 필요, 오류 시 더 많은 패킷 재전송 (GBN의 경우)
2. 작은 윈도우 크기:
    - 장점: 적은 버퍼 요구, 오류 시 재전송 부담 감소
    - 단점: 낮은 처리량, 비효율적인 대역폭 사용
3. 최적 윈도우 크기:
    - 대역폭 지연 곱(Bandwidth-Delay Product)에 근접할 때 최적의 성능

**Q3: Pipelined Protocols에서 사용되는 타임아웃 메커니즘에 대해 설명해주세요.**
A3: Pipelined Protocols의 타임아웃 메커니즘:

1. 목적: 패킷 손실 감지 및 재전송 트리거
2. 설정: RTT(Round Trip Time)를 기반으로 동적으로 조정
3. 동작:
    - GBN: 가장 오래된 미확인 패킷에 대한 단일 타이머 사용
    - SR: 각 패킷마다 개별 타이머 사용
4. 재전송 정책:
    - GBN: 타임아웃 발생 시 윈도우 내 모든 패킷 재전송
    - SR: 타임아웃 발생한 특정 패킷만 재전송
5. 고려사항: 너무 짧으면 불필요한 재전송, 너무 길면 반응 속도 저하

**Q4: Pipelined Protocols에서 발생할 수 있는 문제 상황과 그 해결 방법에 대해 설명해주세요.**
A4: 주요 문제 상황과 해결 방법:

1. 패킷 손실:
    - 해결: 타임아웃 및 재전송 메커니즘 사용
2. 순서 뒤바뀜:
    - GBN: 순서가 맞지 않는 패킷 폐기
    - SR: 버퍼에 저장 후 순서대로 처리
3. 중복 패킷:
    - 해결: 순서 번호를 통한 중복 감지 및 폐기
4. ACK 손실:
    - 해결: 누적 ACK 사용, 타임아웃 후 재전송
5. 윈도우 오버플로우:
    - 해결: 흐름 제어 메커니즘 적용 (예: TCP의 슬라이딩 윈도우)

**Q5: Pipelined Protocols가 실제 네트워크 프로토콜에 어떻게 적용되었는지 예를 들어 설명해주세요.**
A5: Pipelined Protocols의 실제 적용 사례:

1. TCP (Transmission Control Protocol):
    - 슬라이딩 윈도우 메커니즘 사용
    - 선택적 확인 응답(SACK) 옵션으로 SR 개념 적용
2. HDLC (High-Level Data Link Control):
    - Go-Back-N 및 Selective Repeat 모드 지원
3. SCTP (Stream Control Transmission Protocol):
    - 멀티스트리밍과 함께 파이프라이닝 개념 적용
4. QUIC (Quick UDP Internet Connections):
    - 스트림 멀티플렉싱과 함께 파이프라이닝 사용
5. 위성 통신 프로토콜:
    - 긴 지연 시간을 고려한 대규모 윈도우 사용

Pipelined Protocols는 현대 네트워크 통신의 핵심 개념으로, 높은 대역폭과 긴 지연 시간을 가진 네트워크에서 특히 중요합니다. 이 개념을 이해하는 것은 효율적인 네트워크 프로토콜 설계와 최적화에 필수적입니다.

# go back n

## Go-Back-N (GBN)이란:

Go-Back-N은 파이프라인 프로토콜의 한 종류로, 슬라이딩 윈도우 기법을 사용하여 연속적으로 여러 패킷을 전송하는 방식입니다. 오류가 발생하면 특정 시점부터 모든 패킷을 재전송하는 특징을 가지고 있습니다.

## 주요 특징:

1. 연속 전송: 확인 응답(ACK)을 기다리지 않고 여러 패킷을 연속해서 전송합니다.
2. 슬라이딩 윈도우: 송신자는 N개의 패킷으로 구성된 윈도우를 사용합니다.
3. 누적 ACK: 수신자는 성공적으로 수신한 마지막 순서 번호까지의 누적 ACK를 보냅니다.
4. 단순한 수신자: 수신자는 항상 순서대로 패킷을 기대하며, 순서가 맞지 않는 패킷은 폐기합니다.
5. 대량 재전송: 오류 발생 시 윈도우 내의 모든 패킷을 재전송합니다.

## 동작 과정:

![Untitled](https://github.com/user-attachments/assets/7d0a3eca-1c94-46fb-8603-6da3f0434c3d)

1. 송신자:
    - 윈도우 크기(N) 만큼의 패킷을 연속해서 전송합니다.
    - 각 패킷에 순서 번호를 부여합니다.
    - ACK를 받으면 윈도우를 앞으로 이동시킵니다.
    - 타임아웃 발생 시 윈도우 내의 모든 패킷을 재전송합니다.
2. 수신자:
    - 패킷을 수신하면 순서 번호를 확인합니다.
    - 예상한 순서 번호의 패킷이면 수신하고 누적 ACK를 보냅니다.
    - 순서가 맞지 않는 패킷은 폐기하고, 마지막으로 올바르게 수신한 패킷의 ACK를 재전송합니다.
3. 윈도우 관리:
    - 송신 윈도우: ACK를 받으면 윈도우의 하한선을 이동시킵니다.
    - 수신 윈도우: 크기가 1로 고정되어 있어, 항상 다음 예상 순서 번호만을 받아들입니다.
4. 오류 처리:
    - 패킷 손실: 타임아웃 발생 시 윈도우 내 모든 패킷 재전송
    - ACK 손실: 누적 ACK 방식으로 인해 다음 ACK로 해결 가능
    - 순서 뒤바뀜: 순서가 맞지 않는 패킷 폐기

## 기술 질문 및 답변:

**Q1: Go-Back-N 프로토콜의 장단점을 설명해주세요.**
A1:
장점:

1. 단순한 수신자 구현: 순서가 맞지 않는 패킷을 모두 폐기하므로 버퍼 관리가 간단합니다.
2. 효율적인 ACK 처리: 누적 ACK를 사용하여 ACK 오버헤드를 줄입니다.
3. 순서 보장: 항상 순서대로 패킷을 전달합니다.

단점:

1. 불필요한 재전송: 오류 발생 시 이미 성공적으로 전송된 패킷도 재전송될 수 있습니다.
2. 네트워크 대역폭 낭비: 대량 재전송으로 인해 대역폭을 비효율적으로 사용할 수 있습니다.
3. 높은 지연 가능성: 패킷 손실 시 재전송으로 인한 지연이 발생할 수 있습니다.

**Q2: Go-Back-N에서 윈도우 크기(N)가 성능에 미치는 영향을 설명해주세요.**
A2: 윈도우 크기(N)는 다음과 같이 성능에 영향을 미칩니다:

1. 큰 윈도우 크기:
    - 장점: 높은 처리량, 효율적인 대역폭 사용
    - 단점: 오류 발생 시 더 많은 패킷 재전송, 더 큰 버퍼 필요
2. 작은 윈도우 크기:
    - 장점: 오류 시 재전송 부담 감소, 적은 버퍼 요구
    - 단점: 낮은 처리량, 비효율적인 대역폭 사용
3. 최적 윈도우 크기:
    - 대역폭 지연 곱(Bandwidth-Delay Product)에 근접할 때 최적의 성능
    - 네트워크 상태와 애플리케이션 요구사항에 따라 조절 필요

**Q3: Go-Back-N과 Stop-and-Wait 프로토콜의 차이점을 설명해주세요.**
A3: 주요 차이점은 다음과 같습니다:

1. 전송 방식:
    - Stop-and-Wait: 한 번에 하나의 패킷만 전송
    - Go-Back-N: 여러 패킷을 연속적으로 전송
2. 효율성:
    - Stop-and-Wait: 낮은 채널 활용도
    - Go-Back-N: 높은 채널 활용도, 특히 긴 지연 시간의 네트워크에서 효과적
3. 복잡성:
    - Stop-and-Wait: 매우 단순한 구현
    - Go-Back-N: 더 복잡한 윈도우 관리 필요
4. 오류 처리:
    - Stop-and-Wait: 단일 패킷 재전송
    - Go-Back-N: 윈도우 내 모든 패킷 재전송

**Q4: Go-Back-N에서 사용되는 타이머 메커니즘에 대해 설명해주세요.**
A4: Go-Back-N의 타이머 메커니즘:

1. 단일 타이머 사용: 윈도우 내 가장 오래된 미확인 패킷에 대해 하나의 타이머만 유지합니다.
2. 타이머 시작: 패킷 전송 시 타이머를 시작합니다.
3. 타이머 재설정: ACK 수신 시 타이머를 재설정합니다.
4. 타임아웃 처리: 타임아웃 발생 시 윈도우 내 모든 패킷을 재전송합니다.
5. 타임아웃 값 설정: 일반적으로 예상 RTT(Round Trip Time)보다 약간 크게 설정합니다.

**Q5: Go-Back-N 프로토콜이 실제 네트워크 프로토콜에 어떻게 적용되었는지 예를 들어 설명해주세요.**
A5: Go-Back-N의 실제 적용 사례:

1. HDLC (High-Level Data Link Control):
    - 데이터 링크 계층 프로토콜로, Go-Back-N 방식을 옵션으로 제공합니다.
2. X.25 네트워크 프로토콜:
    - 패킷 스위칭 네트워크에서 Go-Back-N을 사용합니다.
3. 초기 TCP 구현:
    - 일부 초기 TCP 버전에서 Go-Back-N과 유사한 방식을 사용했습니다.
4. 위성 통신 프로토콜:
    - 긴 지연 시간을 가진 위성 통신에서 수정된 형태의 Go-Back-N을 사용합니다.
5. 일부 무선 네트워크 프로토콜:
    - 간단한 구현이 필요한 경우 Go-Back-N 방식을 채택합니다.

Go-Back-N은 단순성과 신뢰성 사이의 균형을 제공하는 프로토콜로, 특히 오류율이 낮은 네트워크에서 효과적입니다. 그러나 높은 오류율 환경에서는 불필요한 재전송으로 인한 비효율성 때문에 Selective Repeat와 같은 다른 방식이 선호될 수 있습니다.

# selective repeat

![Untitled 7](https://github.com/user-attachments/assets/e09e80b7-fbf7-4751-ab2b-d1189cd9a8aa)

## Selective Repeat이란:

Selective Repeat은 파이프라인 프로토콜의 한 종류로, 오류가 발생한 패킷만을 선택적으로 재전송하는 방식입니다. 이는 Go-Back-N의 단점을 보완하여 네트워크 리소스를 더 효율적으로 사용합니다.

## 주요 특징:

1. 선택적 재전송: 오류가 발생한 패킷만을 재전송합니다.
2. 개별 확인: 각 패킷에 대해 개별적인 확인 응답(ACK)을 사용합니다.
3. 송수신 윈도우: 송신자와 수신자 모두 N 크기의 윈도우를 사용합니다.
4. 버퍼링: 수신자는 순서가 맞지 않는 패킷도 버퍼에 저장합니다.
5. 복잡한 구현: Go-Back-N에 비해 더 복잡한 로직이 필요합니다.

## 동작 과정:

1. 송신자:
    - 윈도우 크기(N) 만큼의 패킷을 연속해서 전송합니다.
    - 각 패킷에 순서 번호를 부여하고 개별 타이머를 설정합니다.
    - 개별 ACK를 받으면 해당 패킷을 윈도우에서 제거합니다.
    - 타임아웃 발생 시 해당 패킷만 재전송합니다.
2. 수신자:
    - 수신한 패킷의 순서 번호를 확인합니다.
    - 모든 수신 패킷에 대해 개별 ACK를 전송합니다.
    - 순서가 맞지 않는 패킷도 버퍼에 저장합니다.
    - 연속된 패킷을 받으면 상위 계층으로 전달합니다.
3. 윈도우 관리:
    - 송신 윈도우: ACK를 받은 패킷을 제거하고 윈도우를 이동합니다.
    - 수신 윈도우: 연속된 패킷을 처리하면서 윈도우를 이동합니다.
4. 오류 처리:
    - 패킷 손실: 해당 패킷만 재전송
    - ACK 손실: 타임아웃 후 해당 패킷만 재전송
    - 순서 뒤바뀜: 버퍼에 저장 후 순서대로 처리

## 기술 질문 및 답변:

**Q1: Selective Repeat 프로토콜의 장단점을 설명해주세요.**
A1:
장점:

1. 효율적인 대역폭 사용: 오류가 발생한 패킷만 재전송하여 불필요한 재전송을 최소화합니다.
2. 높은 처리량: 특히 높은 오류율 환경에서 Go-Back-N보다 성능이 우수합니다.
3. 낮은 지연: 순서가 맞지 않는 패킷도 버퍼링하여 빠르게 처리할 수 있습니다.

단점:

1. 복잡한 구현: 송수신자 모두 복잡한 버퍼 관리가 필요합니다.
2. 큰 버퍼 요구: 순서가 맞지 않는 패킷을 저장하기 위한 추가 버퍼가 필요합니다.
3. 개별 ACK 오버헤드: 각 패킷마다 ACK를 전송해야 하므로 ACK 트래픽이 증가합니다.

**Q2: Selective Repeat에서 윈도우 크기가 성능에 미치는 영향을 설명해주세요.**
A2: 윈도우 크기는 다음과 같이 성능에 영향을 미칩니다:

1. 큰 윈도우 크기:
    - 장점: 높은 처리량, 효율적인 대역폭 사용
    - 단점: 더 큰 버퍼 필요, 순서 관리의 복잡성 증가
2. 작은 윈도우 크기:
    - 장점: 적은 버퍼 요구, 단순한 관리
    - 단점: 상대적으로 낮은 처리량
3. 최적 윈도우 크기:
    - 대역폭 지연 곱(Bandwidth-Delay Product)에 근접할 때 최적의 성능
    - 네트워크 상태와 애플리케이션 요구사항에 따라 조절 필요
4. 주의사항: 윈도우 크기는 순서 번호 공간의 절반을 초과하지 않아야 합니다.

**Q3: Selective Repeat와 Go-Back-N의 주요 차이점을 설명해주세요.**
A3: 주요 차이점은 다음과 같습니다:

1. 재전송 방식:
    - Go-Back-N: 오류 발생 시 윈도우 내 모든 패킷 재전송
    - Selective Repeat: 오류가 발생한 패킷만 선택적으로 재전송
2. ACK 처리:
    - Go-Back-N: 누적 ACK 사용
    - Selective Repeat: 개별 ACK 사용
3. 수신자 버퍼:
    - Go-Back-N: 순서가 맞지 않는 패킷 폐기
    - Selective Repeat: 순서가 맞지 않는 패킷도 버퍼에 저장
4. 윈도우 크기:
    - Go-Back-N: 송신자만 N 크기의 윈도우 사용
    - Selective Repeat: 송신자와 수신자 모두 N 크기의 윈도우 사용
5. 복잡성:
    - Go-Back-N: 상대적으로 단순한 구현
    - Selective Repeat: 더 복잡한 구현 필요

**Q4: Selective Repeat에서 사용되는 타이머 메커니즘에 대해 설명해주세요.**
A4: Selective Repeat의 타이머 메커니즘:

1. 개별 타이머: 각 패킷마다 별도의 타이머를 유지합니다.
2. 타이머 시작: 패킷 전송 시 해당 패킷의 타이머를 시작합니다.
3. 타이머 취소: ACK 수신 시 해당 패킷의 타이머를 취소합니다.
4. 타임아웃 처리: 타임아웃 발생 시 해당 패킷만 재전송합니다.
5. 타임아웃 값 설정: 예상 RTT(Round Trip Time)를 기반으로 설정하며, 네트워크 상황에 따라 동적으로 조절할 수 있습니다.

**Q5: Selective Repeat 프로토콜이 실제 네트워크 프로토콜에 어떻게 적용되었는지 예를 들어 설명해주세요.**
A5: Selective Repeat의 실제 적용 사례:

1. TCP의 SACK(Selective Acknowledgment) 옵션:
    - TCP에서 Selective Repeat의 개념을 적용한 확장 기능입니다.
2. SCTP(Stream Control Transmission Protocol):
    - 멀티스트리밍 기능과 함께 Selective Repeat 방식의 오류 복구를 사용합니다.
3. 위성 통신 프로토콜:
    - 긴 지연 시간을 가진 위성 링크에서 효율적인 전송을 위해 사용됩니다.
4. 일부 무선 네트워크 프로토콜:
    - 높은 오류율 환경에서 효율적인 데이터 전송을 위해 채택됩니다.
5. HDLC(High-Level Data Link Control):
    - 데이터 링크 계층 프로토콜로, Selective Repeat 모드를 제공합니다.

Selective Repeat는 높은 오류율 환경이나 긴 지연 시간을 가진 네트워크에서 특히 효과적입니다. 그러나 구현의 복잡성 때문에 모든 상황에 적합하지는 않으며, 네트워크 특성과 애플리케이션 요구사항을 고려하여 적절히 선택해야 합니다.
